
zookeeper总结
=
### 2.1概念总结
#### 1.zookeeper是一个分布式的程序，半数以上的节点存活就可以继续使用
#### 2.zookeeper数据存储在内存，高吞吐量低延时
#### 3.zookeeper临时节点在会话期间存在，会话结束临时节点消失
#### 4.zookeeper是高性能的，特别适合“读”多余“写”的程序，因为写会导致服务器同步
#### 5.zookeeper底层其实只提供了数据管理和数据节点监听服务

### 2.2会话（session）
session指的是zookeeper服务器与客户端的会话。在会话创建前服务器会创建一个sessionID，无论哪台服务器分配的sessionID都全局唯一。客户端与zookeeper服务器是一个TCP长连接。客户端启动时会与服务器创建一个TCP长连接，客户端可以通过TCP连进行心跳检测保持有效的会话，可以通过TCP发送请求并且接受响应，并且还可以通过TCP连接接收来自服务器的watcher通知。sessionTimeout用来设置会话超时时间，当服务器负载较大或者网络原因中断连接，在sessionTimeout时间内如果重新连接上集群中任意一台服务器那么会话仍然有效。

### 2.3Znode
ZNode分为临时节点和持久节点，临时节点在会话有效时存在

### 2.4版本
zookeeper上每个ZNode会存储数据，对应每个ZNode会维护一个stat的数据结构，version（节点版本），sversion（子节点版本），aversion（acl版本）

### 2.5watcher
zookeeper允许用户在节点上注册watcher，当特定事件触发的时候，zookeeper服务端会将事件通知到客户端上，该机制是实现分布式协调服务的重要特性

### 2.5ACL
ACL（AccessControlLists）策略来管理用户权限
zookeeper定义了五种权限：
CREATE：创建子节点的权限
DELETE：删除子节点的权限
READ：读取节点数据和子节点列表的权限
WRITE：节点数据的权限
ADMIN：修改节点权限




## CAP概念总结
CAP(consistency一致性,availability可用性，partition-tolerance分区容忍性)。关系型数据库注重C和A，NOSQL数据库注重A和P，或C和P

![](https://github.com/RyougiSHikii/learningSummary/blob/master/image/cap.png)

 数据在A、B、C三个节点保留了三份，如果对A节点进行修改，然后客户端通过网络要读取该数据，那么客户端读取的操作什么时候返回？
    有两种处理方式：一种是选择一致性（C），等待B、C节点更新数据完成以后再返回客户端请求，这种就是强一致性读，这种情况牺牲了可用性，
    响应速度有所下降，节点越多同步操作越多性能越差。
    
    另一种是允许读操作立即返回，容忍数据不一致性问题，牺牲数据一致性换来可用性，网络中的数据副本可以多一些，唯一不能保证数据一致性。
    分布式事务。在关系型数据库中，
    关系型数据库遵守ACID准则，原子性（Atomicity），一致性（Consistency），隔离性（isolation），持久性（durability）。
    
    例如一家银行的存款事务，有一条交易插入到流水表。同时还必须保证账户余额改变，这两个操作必须在一个事务中完成，保证相关数据的一致性。
    而CAP理论中C指的是一个数据和多个备份的读写一致性。表面上看不是一回事，但本质上确是相同的：都是在相关操作全部完成以后才返回。
    对分布式系统，这就是分布事务问题。
    
    一般分布式事务采用两段提交策略来实现，这是非常耗时的过程，会严重影响系统的效率，在实践中应该尽量避免使用它。
    而事务要求又不能降低，系统性能受到很大的影响，一般我们队这种场景避免分散存储。
    
    因为这个原因，关系型数据库扩展性（分区容忍性）受到了限时。当然对于Nosql数据库也一样，只是nosql数据库在设计中弱化了事务。
    
    关系型数据库为了保证C、A而牺牲了P，在尽量避免分布式事务这一点来看应该没错，而Nosql数据库弱化
 
