# 乐观锁悲观锁
- **乐观锁**
  乐观锁假设总是处在没有竞争的情况下，对共享变量总是不加锁，在更新的时候判断变量是否被改变过决定是否更新。乐观锁比较典型的实现方式是
  CAS（compare and swap）。
  **CAS**：包含三个操作数据：主内存中存储的值（V），进行比较的预期值（A），拟写入内存的值（B），如果A和V相同则将B写入到V所在的地址，否则不进行操作。
   CAS分为两步操作：1、比较V和A(lock read,load获取V的值 use(A))，2、写入值B(store write unlock)，在java中这两步操作由java本地方法保证操作原子性
   （通过内存屏障实现？）
   
   乐观锁包含以下几个问题：
   
   - **ABA问题**：线程1读取了数据A然后挂起，线程2将数据A修改为B后再将数据修改为A然后线程1激活，线程1缓存数据A和主内存数据对比得到数据没变
   但可能已经被修改过。可以采用版本号解决
   - **自旋问题**：由于竞争激烈，线程不停循环直到成功，cpu开销大并且执行结束内存顺利冲突从而导致流水线重排（？）。可以采用处理器的pause指令延时一会
   - **一次只能保证一个变量**：jdk1.5以后可以保证引用原子性。

- **悲观锁**
 线程对共享变量访问总是采用独占式，在获得锁期间其他线程不能访问直到释放锁。synchronized就是一种悲观锁。
 
 悲观锁的缺陷：
 - **一个线程独占共享资源，其他线程不能访问**
 - **在多线程下，加锁和释放锁会导致上下文切换和调度延时，影响性能**
 - **一个高优先级的线程可能会等待低优先级线程释放锁，造成优先级倒置，可能引起性能风险**


  **乐观锁和悲观锁的使用**
 在资源竞争不激烈的时候synchronized阻塞唤醒以及用户态内核态造成额外的cpu浪费；而CAS（AtomicInteger）基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率小，因此可以获得较高的性能
 在资源竞争激烈的情况下，CAS较高概率出现自旋，浪费CPU资源，性能远低于synchronized
 在jdk1.6以后，synchronized进行了优化，基于lock-free队列实现。基本思想是后自旋，竞争切换后继续竞争锁，稍微牺牲公平性但获得高吞吐量。
