# 乐观锁悲观锁
- **乐观锁**

  乐观锁假设总是处在没有竞争的情况下，对共享变量总是不加锁，在更新的时候判断变量是否被改变过决定是否更新。乐观锁比较典型的实现方式是
  CAS（compare and swap）。
  **CAS**：包含三个操作数据：主内存中存储的值（V），进行比较的预期值（A），拟写入内存的值（B），如果A和V相同则将B写入到V所在的地址，否则不进行操作。
   CAS分为两步操作：1、比较V和A(lock read,load获取V的值 use(A))，2、写入值B(store write unlock)，在java中这两步操作由java本地方法保证操作原子性
   （通过内存屏障实现？）
   
   乐观锁包含以下几个问题：
   
   - **ABA问题**：线程1读取了数据A然后挂起，线程2将数据A修改为B后再将数据修改为A然后线程1激活，线程1缓存数据A和主内存数据对比得到数据没变
   但可能已经被修改过。可以采用版本号解决
   - **自旋问题**：由于竞争激烈，线程不停循环直到成功，cpu开销大并且执行结束内存顺利冲突从而导致流水线重排（？）。可以采用处理器的pause指令延时一会
   - **一次只能保证一个变量**：jdk1.5以后可以保证引用原子性。

- **悲观锁**
